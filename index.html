<!DOCTYPE html>
<html lang="en">
    <head>
        <title>three.js webgl - geometry - terrain</title>
        <meta charset="utf-8">
        <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
        <style>
            body {
                color: #61443e;
                font-family:Monospace;
                font-size:13px;
                text-align:center;

                background-color: #bfd1e5;
                margin: 0px;
                overflow: hidden;
            }

            #info {
                position: absolute;
                top: 0px; width: 100%;
                padding: 5px;
            }

            a {

                color: #a06851;
            }

        </style>

        ////////////////////--SHADERS--/////////////////////////////////
        //VERTEX-SHADER
         //<script id="shader-vs" type="x-shader/x-vertex">
         //attribute vec3 aVertexPosition;

         //void main() {
         // gl_Postition = projectMatrix * modelViewMatrix * vec4(position, 1.0);   
         //}
         

         //</script>

         //FRAGMENT-SHADER
         //<script id="shader-vs" type="x-shader/x-fragment">
            //void main() {
                gl_FragColor = vec4( 1.0, 0.0, 0.0 1.0 );
         // }
        // </script>

        ////////////////////////////////////////////////////////////////

    </head>
    <body>

        <div id="container"><br /><br /><br /><br /><br />Generating world...</div>
        <div id="info"><a href="http://threejs.org" target="_blank">three.js</a> - webgl terrain demo<br />(left click: forward, right click: backward)</div>

        <script src="js/build/three.min.js"></script>
        
        <script src="js/controls/FirstPersonControls.js"></script>
        <script src="js/ImprovedNoise.js"></script>
        <script src="js/Detector.js"></script>
        <script src="js/libs/stats.min.js"></script>

        <script src="js/controls/OrbitControls.js"></script>

        <script>

            var geometry, meshen;
            var container, stats;
            var camera, controls, scene, renderer;
            var mesh, texture;

            var clock = new THREE.Clock();


            init();
            animate();

            function init() {

                container = document.getElementById( 'container' );
                scene = new THREE.Scene();

                camera = new THREE.PerspectiveCamera( 60, window.innerWidth / window.innerHeight, 1, 20000 );
                camera.position.set(150,60,100);
                camera.lookAt( scene.position );

                controls = new THREE.OrbitControls( camera );
                controls.daming = 0.2;
                controls.addEventListener( 'change', render );

                //Material for raindrop
                pmaterial = new THREE.PointCloudMaterial({
                    color: 0xFFFFFF,
                    size: 2,
                    map: THREE.ImageUtils.loadTexture(
                        "images/sprite.png"
                    ),
                    //blending: THREE.AdditiveBlending,
                    transparent: true
                });

                //create the raindrops
                geomparticle = new THREE.Geometry();

                //Create where they will be
                for ( i = 0; i < 5; i ++ ) {

                    var vertex = new THREE.Vector3();
                   	vertex.x = Math.round(Math.random() * 94 - 47);
                    vertex.z = Math.round(Math.random() * 94 - 47);
                    vertex.y = Math.round(Math.random() * 50 + 50);
                    geomparticle.vertices.push( vertex );

                }

                //create the particles
                particles = new THREE.PointCloud( geomparticle, pmaterial);

                //add to scene 
                scene.add(particles);

                var material = new THREE.MeshBasicMaterial( { color: 0xffffff, wireframe: true } );
                geometry = new THREE.PlaneGeometry( 100, 100, 40, 40 );
                meshen = new THREE.Mesh( geometry, material );
                meshen.rotation.x = - Math.PI/2;

                
                //Create Box
                var theBox = new THREE.BoxGeometry(100, 70, 100, 4);
                var boxMaterial = new THREE.MeshBasicMaterial( { color: 0xbfd1e5 , side: THREE.BackSide } );
                var box = new THREE.Mesh(theBox, boxMaterial);

                scene.add(box);
                scene.add(meshen);

                //startvärden
                geometry.vertices.z = 1;
                /*
                geometry.vertices[150].z = 15;
                geometry.vertices[151].z = 15;
                geometry.vertices[152].z = 15;
                geometry.vertices[190].z = 20;
                geometry.vertices[192].z = 20;
                geometry.vertices[191].z = 20;
                geometry.vertices[230].z = 20;
                geometry.vertices[231].z = 20;
                geometry.vertices[232].z = 20;
                geometry.vertices[233].z = 15;
                geometry.vertices[229].z = 15;
                geometry.vertices[270].z = 15;
                geometry.vertices[189].z = 15;
                geometry.vertices[193].z = 15;
                geometry.vertices[271].z = 15;
                geometry.vertices[272].z = 15;*/

                
                
                var theRow = 40;

                //LAX WENDROFF stegmetod/////////////////////////////////////

                H = new Array();
                U = new Array();
                V = new Array();

                Hx = new Array();
                Hy = new Array();
                Ux = new Array();
                Uy = new Array();
                Vx = new Array();
                Vy = new Array();

                
                for ( var i = 0; i < (theRow * theRow); i++ )
                {
                        Hx.push(0);
                        Hy.push(0);
                        Ux.push(0);
                        Uy.push(0);
                        Vx.push(0);
                        Vy.push(0);
                }

                for ( var i = 0; i < ( (theRow + 1) * (theRow + 1) ); i++ )
                {
                        U.push(0);
                        V.push(0);
                }


                ////////////////////////////////////////////////////////////////////


                renderer = new THREE.WebGLRenderer();
                renderer.setClearColor( 0x000000 );
                renderer.setPixelRatio( window.devicePixelRatio );
                renderer.setSize( window.innerWidth, window.innerHeight );

                container.innerHTML = "";

                container.appendChild( renderer.domElement );

                stats = new Stats();
                stats.domElement.style.position = 'absolute';
                stats.domElement.style.top = '0px';
                container.appendChild( stats.domElement );

                //

                window.addEventListener( 'resize', onWindowResize, false );

            }


            function onWindowResize() {

                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();

                renderer.setSize( window.innerWidth, window.innerHeight );

                controls.handleResize();

            }



            function animate() {

                requestAnimationFrame( animate );

                render();
                stats.update();
                controls.update();

            }

            function render() {

                var dx = 1, dy = 1, dt = 0.05, g = 9.81, v = 1.3, h;   //dt = 1/60 
                var row = 40;
                var posRain = new Array();
                var j;

                h = (Math.pow(v,2))/(2*g);


                //Rain falling behaviour
                for(var p = 0; p < particles.geometry.vertices.length; p++)
                {
                    particles.geometry.vertices[p].y -= v;
 	            }

                //Reflective boundary conditions
                for(var i = 0; i < row; i++)
                {
                    geometry.vertices[i*row].z = geometry.vertices[(i*row) + 1].z;
                    geometry.vertices[(i*row) + 40].z = geometry.vertices[(i*row) + 39].z;    
                    geometry.vertices[i].z = geometry.vertices[i + row].z;
                    geometry.vertices[40*row + i].z = geometry.vertices[39*row + i].z;   
                    
                    U[i*row].z = U[(i*row) + 1].z;
                    U[(i*row) + 40].z = U[(i*row) + 39].z;    
                    U[i].z = - U[i + row].z;
                    U[40*row + i].z = - U[39*row + i].z;  
                    
                    V[i*row].z = - V[(i*row) + 1].z;
                    V[(i*row) + 40].z = - V[(i*row) + 39].z;    
                    V[i].z = V[i + row].z;
                    V[40*row + i].z = V[39*row + i].z;                   
                }                


                //LAX WENDROFF

                //Första steget: 
                
                //X-LED
                for ( var i = 0; i < ( (row + 1) * (row )); i++ )
                {
                    Hx[i] = (( geometry.vertices[i + 41].z + geometry.vertices[i + 40].z ) / 2 ) - (dt / (2 * dx)) * ( U[i + 41] - U[i + 40]);
                    Ux[i] = (( 0.5 * ( U[i + 41] + U[i + 40] ) - ( dt / (2 * dx)) * ( Math.pow(U[i + 41], 2) + (( 0.5 * g * geometry.vertices[i + 41].z - ( Math.pow( U[i + 40], 2) + 0.5 * g * geometry.vertices[i + 40].z ))))));
                    Vx[i] = 0.5 * (V[i + 40] + V[i + 41]) - (dt / (2 * dx)) * (( U[i + 41] * V[i + 41] - U[i + 40] * V[i + 40] ));

                }

                //Y-LED
                for( var i = 0; i < ((row ) * (row + 1 )); i++)
                {
                    Hy[i] = 0.5 * ( geometry.vertices[i + 41].z + geometry.vertices[i + 1].z ) - (dt / ( 2 * dy )) * ( V[ i + 41] - V[i + 1] );
                    Uy[i] = 0.5 * ( U[i + 1 ] + U[i + 41] ) - (dt / (2 * dy)) * (( V[i + 41] * U[i + 41] - V[i + 1] * U[i + 1] ));
                    Vy[i] = 0.5 * ( V[i + 41] + V[i + 1] ) - (dt / (2 * dy)) * ( Math.pow(V[i + 41], 2) + 0.5 * g * geometry.vertices[i + 41].z - ( Math.pow(V[i + 1], 2) + 0.5 * g * geometry.vertices[i + 1].z ));
                }

                //Andra steget:
                //j = 0;
                for( var i = 41; i < ((row ) * (row + 1 )); i++)
                {
                    while(j < particles.geometry.vertices.length)
                    {                    
                        if (   Math.abs(particles.geometry.vertices[j].x - geometry.vertices[i].x) < 2.5
                        	&& Math.abs(particles.geometry.vertices[j].z + geometry.vertices[i].y) < 2.5
                        	&& Math.abs(particles.geometry.vertices[j].y - geometry.vertices[i].z) < 1)
                        {
							//console.log(Math.abs("hej"))
							geometry.vertices[i].z = 3;

							particles.geometry.vertices[j].x = Math.round(Math.random() * 94 - 47);
                        	particles.geometry.vertices[j].z = Math.round(Math.random() * 94 - 47);
                        	//Reset height
                        	particles.geometry.vertices[j].y = Math.random() * 50 + 50;

                        }
                        
                        j++;
                    }

                    geometry.vertices[i].z = geometry.vertices[i].z - (dt/dx) * ( Ux[i - 40] - Ux[i - 41] ) - (dt / dy) * (Vy[i - 1] - Vy[i - 41]);

                    
                    U[i] = U[i] - (dt / dx) * (Math.pow(Ux[i - 40], 2) + ( 0.5 * g * Hx[i - 40] - ( Math.pow(Ux[i - 41], 2) + 0.5 * g * Hx[i - 41] ))) - (dt / dy) * (Vy[i - 1] * Uy[i - 1] - Vy[i - 41] * Uy[i - 41] );
                    
                    V[i] = V[i] - (dt / dx) * ( Ux[i - 40] * Vx[i - 40] - Ux[i - 41] * Vx[i - 41] ) - (dt / dy) * (( Math.pow(Vy[i - 1], 2) + 0.5 * g * Hy[i - 1] ) - ( Math.pow(Vy[i - 41], 2) + 0.5 * g * Hy[i - 41] ));
                    j=0;
                    
                }

                meshen.geometry.verticesNeedUpdate = true;
                particles.geometry.verticesNeedUpdate = true;

                //controls.update( clock.getDelta() );
                renderer.render( scene, camera );


            }

        </script>

    </body>
</html>
